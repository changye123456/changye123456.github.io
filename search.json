[{"title":"wp","path":"/2025/12/21/wp/","content":"MOECTF如何上传图片将图片文件夹放在source文件夹下面，一定不要与文件名字一样， 之后mark语法即可(赞美徐✌) 1.upx_revange 显然上面版本号下面0D将upx！扣掉 加上55 50 58 21（upx！）通过编辑中的插入字节 之后 upx -d脱壳0 lY7bW\\ck?eyjX7]TZ\\}CVbh\\tOyTH6jH7XmFifG]H7明显为密文 sub_7FF6F2A61000直接就是base64标准表 Block ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_; 这个block是指针，指向的偏移地址就是base64表 t *ptr ^ 0xE;证明base64异或0xe之后进行base64加密 OLMJKHIFGDEBC@A^_]Z[XYVWTolmjkhifgdebca~|}z{xyvwt?:;8967%!这是标准base64表异或然后加密的结果 这里插一句一开始让ai干的结果生成的新的base64表示错的，导致否定了这个正确的思路，又整了半天 这已经能看见flag的形状，那为什么不对呢， 因为这是字符串其中\\表示\\ 得出答案moectf{Y0u_Re4l1y_G00d_4t_Upx!!!} 2ezandroid.pro 这里补充一下看s0文件先导入c头文件，之后将第一个参数结构体变为JNEVN 这里有loadlib加载native库，这一看就是用ida看so文件 着长长的东西一看就是密文 sm4Encrypt是sm4加密 这里我浅浅的看一下sm4加密的原理 sm4是分组加密，一组明文（128位，16字节，4字）（X0,X1,X2,X3） 密钥（128位，16字节，4字） 得到的密文也是（128位，16字节，4字） 加密32次轮迭代，1次反序变换 132次轮加密 每轮要1字，轮函数接受4字密文与1字密钥 接着x4 F（x0， x1, x2, x3, rk0） ​ x5 F(x1, x2, x3, x4, rk)以此类推得到36个字 2一次反序变换 ​ 将得到的sm4最后4个字反序 ​ (Y0,Y1,Y2,Y3) (X35, X34, X33, X32) 回到这个题moectf2025!!!!!!（4字）一看就是密钥 这里没看见iv（参见明文中） 这里猜一下是标准用ecb（电子密码本）：使用同一密钥，无iv raw（不做任何处理）当时做时选的hex没选raw导致flag全变为16进制的 moectf{SM4_Android_I5_Funing!!!} rusty_sudoku（数独）（moectf的逆向终章）我一开始并不知道数独是什么，前了解一下数读为9乘以9（每个3乘以3不重复）一行一列全含1-9 这***一看就是数独原来的棋盘找个求解器 导入数据‘.’换为0 然后 有个细节一定要打断点再输入，否则直接关了 2?ctf（排序规则先week的reverse再misc）Reverse1PlzDebugMe 开局找main函数，然后并没找到main函数，这说明他在藏，直接（shift+f12）找字符串，定位到相应区域 简单的异或，所以只要将密文当输入，再异或，就可知明文 这里的条件很麻烦，存在两步验证，这里可以绕过条件(其实简单法是change bytes, 密文当输入patch进去)(本方法是绕过+找密钥) 显然是要比较的，jz要cmp返回值全为0 这里直接修改第一个jnz为jmp loc_401735，直接将改为必然 sub_401648(123456); for ( n31 = 0; n31 = 31; ++n31 ) byte_415060[n31] = sub_40167D((unsigned __int8)byte_415060[n31]); if ( byte_415060[n31] != byte_410020[n31] ) sub_40160C(Pity! Wrong flag! ); return 0; 这里由于其为1个1个比较，本体解题思路是提取通过加密后的到密文与input异或得密钥，然后与标准密钥异或的明文 这里一个个比较只要有一个不对就退出，那我就让其恒等就行这里由于其为1个1个比较，本体解题思路是提取通过加密后的到密文与input异或得密钥，然后与标准密钥异或的明文 对着条件中的！按tab键，将jz改为jmp 一定要再patch后应用到原文件，要不然原来的程序并不会进行修改，动调就会失败（ida在进行分析时是对复制产生的文件分析，而非原文件） 摘取加密的密文，接下来该找flag加密成的密文 对for循环按tab 因为for循环原来就是比较(比较的dl为byte_415060为input加密) offset byte_410020这是flag加密成的密文的偏移地址 找到flag加密成的密文 #includestdio.hint main(void) char ew[] = 0xC,0xD,0xF1,0x73,0xCE,0xE6,0x60,0x80,0x5,0xC1,0xF1,0x4,0x4D,0xA8,0x44,0x43,0x1C,0x95,0x84,0xC8,0x20,0x9C,0x8F,0x3,0xD5,0xD1,0x97,0x34,0xBD,0xBF,0xC5，0x7A; char e[] = 1111111111111111111111111111111111111111111111111111111111111111111111111; char temp[32] = 0; char c[32] = 0x5B,0x50,0xA1,0x25,0x84,0x8E,0x61,0xC4,0x6B,0xBB,0xAE,0x5,0xB,0xC6,0x3D,0x42,0x5A,0xFB,0xC1,0xC9,0x4E,0xE9,0x8D,0x50,0x91,0x87,0x87,0x24,0xAD,0xAF,0xD5,0x36; for(int i=0; i32; i++) temp[i] = ew[i]^e[i]; printf(%c, temp[i]^c[i]); 结果为flag{Y0u_Kn0w_H0w_t0_D3bug!!!!!} 2ezCSharp用ida看 这很抽象，并且用字符串查找什么都没有 看函数名EncodedFlagAttribute__get_EncodedValue EncodedFlagAttribute__.ctor\tseg000 FlagContainer__.ctor Program__Main Program__DecodeFlag Program__.ctor Program__.cctor 使用__（双下划线）很明显是c#.net命名原则.ctor（实例构造函数）.cctor（静态构造函数） 首先寻找main函数，也就是入口点 这附件直接给了入口点，进入发现文件的主题逻辑 flag Container里 找到密文 之后找到解密函数 private static string DecodeFlag(string encoded) char[] array = encoded.ToCharArray(); for (int i = 0; i array.Length; i++) char c = array[i]; char c2 = c; if (c2 != !) switch (c2) case a: array[i] = z; break; case b: case c: case d: case e: case f: case g: case h: case i: case j: case k: case l: case m: case n: case o: case p: case q: case r: case s: case t: case u: case v: case w: case x: case y: case z: array[i] -= \\u0001; break; else array[i] = _; return new string(array); 很明显是类似于凯撒加密 \\u0001（\\u后跟4个16进制）表示unicode字符，通常写作U+0001（码点），一个码点对应一个字符，这里强制类型转换为整型 #includestdio.h#includestring.hint main(void) char array[] = D1ucj0u!tqjwf!fohjoffsjoh!xj!epspqz!ju!gvo!2025; for (int i = 0; i strlen(array); i++) if (array[i] != !) switch (array[i]) case a: array[i] = z; break; case b: case c: case d: case e: case f: case g: case h: case i: case j: case k: case l: case m: case n: case o: case p: case q: case r: case s: case t: case u: case v: case w: case x: case y: case z: array[i] -= 1; break; default : break; else array[i] = _; printf(%s, array); return 0; 运行得D1tbi0t_spive_engineering_wi_doropy_it_fun_2025（套上flag{}就是正确flag） 3.ezcalculate 打断点是加密的逻辑 很明显先加上再异或之后减去key 逆回去就是先加再异或再减； 这样我们将密文当输入输进去 注意要对齐第一个输入的元素按change byte 如果多选了地址就不是修改数据了 之后的 当然由于有长度限制导致输入少了一个 这里还是写了个解密代码 #includestdio.h#includestring.hint main(void) unsigned char decrpty[] = 0x33, 0x1D, 0x32, 0x44, 0x2A, 0x54, 0x45, 0x2C,0x2E, 0x74, 0x8C, 0x4B, 0x40, 0x42, 0x43, 0x73,0x71, 0x82, 0x24, 0x35, 0x10, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00; char key[] = wwqessgxsddkaao123wms; for(int i = 0; istrlen(decrpty); i++) decrpty[i] += key[i%strlen(key)]; decrpty[i] ^= key[i%strlen(key)]; decrpty[i] -= key[i%strlen(key)]; printf(%s , decrpty); return 0; flag{Add_X0r_and_Sub}","tags":["reverse"]},{"title":"Flower花指令和壳的学习","path":"/2025/11/21/Flower花指令的学习/","content":"flower是花指令，花指令是什么？其实就是插入垃圾指令，我好不容易写出的程序怎能让你这么轻易的逆出来。所以我们要通过修改汇编去破除花指令。 我们不妨想一下哪里能插入垃圾指令。你看jmp跳转以及call指令等等地方都是不二之选。 在了解花指令之前，我们先要学习ida的反汇编机制。 1 线性扫描算法，线性一条流水线上的，想想c语言的线性顺序，类比一下这就是从头到尾扫描，都解释为指令，这就使其如果遇到数据也可能错误反汇编，在反汇编代码中插入数据，反汇编就会失败。 2 递归下降算法，其根据可能执行的逻辑进行反汇编，一般是在遇到分支跳转和call指令时发挥作用，jmp指令其就不会看jmp与跳转到的地址中间的汇编代码，而例如jz等条件跳转其就会分析两条路径（跳转与不跳转）。 花指令（可以在main函数中也可以在主函数之前）的基本类型拥有以下几种 1 插入无关指令 (1)就如调用一些无用的寄存器 add eax, ebx push eax 其就可以插入一个无用的ecx寄存器去干扰你的静态分析 (2)插入无关数据是ida错误解析（可变长度指令，不同指令有不同长度）（这类解法是将无关数据nop掉） 就比如 jmp local（） 80 90 65 (垃圾指令) local ： 2 分支跳转 （由于递归下降算法，条件跳转需要分析两条路）这类解法是将无关数据nop掉 xor eax,eax(自身异或一定为0) cmp eax , 0 je local_3 junk code（导致反汇编失败） local 3 当然还有jz与jnz（永真）跳转到同一个地址。这个也与上面的花指令手法差不多 3 间接跳转 call $+5 -$为当前地址，位置无关指令仅是跳转到下一个页面。 pop rax (相当于将此地的地址存在rax寄存器中) add rax, 10 jmp rax 由于ida的静态分析无法识别出rax寄存器储存的动态地址，导致其跳转错乱，没法讲正确的指令解析出来。 解决方法：将call 一直到rax存的地址之前的全nop掉4 内部跳转 local_2 E9 78 80 jmp local_2 +1(有跳到内部了) 解决方法很简单 将机器码中的第一个地址存的E9 nop掉5 破坏栈平衡 （调用前与调用后需要栈平衡，即调用前与调用后） -call(相当于push+jmp)ret(相当于pop+jmp) （1）xor eax, eax jz s s: add esp, s-可以插入垃圾指令了 (2) movl countine, esp ret-（此时仅仅只会跳转到countine位置，而并不会返回原位置）第一回用blog分享所学的知识，还不会插入图片，下回我会学插入图片的，写的也不够好，请包容。写博客确实并非易事，猫写完都得累趴下，","tags":["逆向,学习笔记"]},{"title":"wuye的逆向之旅始篇","path":"/2025/11/18/wuye的逆向之旅始篇/","content":"本人是来自JNU的逆向手，主攻逆向，这便是开始的篇章吧","tags":["逆向"]},{"title":"Hello World","path":"/2025/11/13/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"}]