<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>逆向手的自我修养 | wuye的博客</title><meta name="author" content="无夜"><meta name="copyright" content="无夜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="假期逆向魔法师学习法术的目标(去想，去学，去征服) des加密（已解决） frida的使用，安卓逆向 去平坦化 aes加密 混淆 反调试 sm4 go与rust的处理 linux内核与gdb z3， dfs， smc  还有每日的练题，语言和wp学习 1.try-catch与结构化异常处理（SEH）（全称[Structure Exception Handler]seh是windows系统对c&amp;#x">
<meta property="og:type" content="article">
<meta property="og:title" content="逆向手的自我修养">
<meta property="og:url" content="https://changye123456.github.io/2026/01/24/%E9%80%86%E5%90%91%E6%89%8B%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/index.html">
<meta property="og:site_name" content="wuye的博客">
<meta property="og:description" content="假期逆向魔法师学习法术的目标(去想，去学，去征服) des加密（已解决） frida的使用，安卓逆向 去平坦化 aes加密 混淆 反调试 sm4 go与rust的处理 linux内核与gdb z3， dfs， smc  还有每日的练题，语言和wp学习 1.try-catch与结构化异常处理（SEH）（全称[Structure Exception Handler]seh是windows系统对c&amp;#x">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://changye123456.github.io/images/b0c1d74766dd8bce0ad860be15c46993a.jpg">
<meta property="article:published_time" content="2026-01-24T03:23:05.000Z">
<meta property="article:modified_time" content="2026-02-22T13:11:18.754Z">
<meta property="article:author" content="无夜">
<meta property="article:tag" content="reverse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://changye123456.github.io/images/b0c1d74766dd8bce0ad860be15c46993a.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "逆向手的自我修养",
  "url": "https://changye123456.github.io/2026/01/24/%E9%80%86%E5%90%91%E6%89%8B%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/",
  "image": "https://changye123456.github.io/images/b0c1d74766dd8bce0ad860be15c46993a.jpg",
  "datePublished": "2026-01-24T03:23:05.000Z",
  "dateModified": "2026-02-22T13:11:18.754Z",
  "author": [
    {
      "@type": "Person",
      "name": "无夜",
      "url": "https://changye123456.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://changye123456.github.io/2026/01/24/%E9%80%86%E5%90%91%E6%89%8B%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '逆向手的自我修养',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">wuye的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">逆向手的自我修养</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">逆向手的自我修养</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-24T03:23:05.000Z" title="发表于 2026-01-24 11:23:05">2026-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-02-22T13:11:18.754Z" title="更新于 2026-02-22 21:11:18">2026-02-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="假期逆向魔法师学习法术的目标-去想，去学，去征服"><a href="#假期逆向魔法师学习法术的目标-去想，去学，去征服" class="headerlink" title="假期逆向魔法师学习法术的目标(去想，去学，去征服)"></a>假期逆向魔法师学习法术的目标(去想，去学，去征服)</h1><ol>
<li>des加密（已解决）</li>
<li>frida的使用，安卓逆向</li>
<li>去平坦化</li>
<li>aes加密</li>
<li>混淆</li>
<li>反调试</li>
<li>sm4</li>
<li>go与rust的处理</li>
<li>linux内核与gdb</li>
<li>z3， dfs， smc</li>
</ol>
<p>还有每日的练题，语言和wp学习</p>
<h1 id="1-try-catch与结构化异常处理（SEH）（全称-Structure-Exception-Handler"><a href="#1-try-catch与结构化异常处理（SEH）（全称-Structure-Exception-Handler" class="headerlink" title="1.try-catch与结构化异常处理（SEH）（全称[Structure Exception Handler]"></a>1.try-catch与结构化异常处理（SEH）（全称[Structure Exception Handler]</h1><p>seh是windows系统对c&#x2F;c++程序做的语法拓展，用于处理异常事件的程序控制结构，</p>
<p>#include &lt;windows.h&gt;&#x2F;&#x2F;包含windows中的api与seh的相关定义</p>
<p>seh含有-try{}<em>-catch函数</em></p>
<p>与-try{}_final函数</p>
<p>由于ida的反编译语言是c&#x2F;c++，于是我了解一下c&#x2F;c++中的seh</p>
<p>主要是（windows的seh检验）（块检验）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct _EXCEPTION_REGISTRATION_RECORD &#123;</span><br><span class="line">    struct _EXCEPTION_REGISTRATION_RECORD* Next;  // 指向下一个节点的指针</span><br><span class="line">    PEXCEPTION_ROUTINE Handler;                   // 异常处理函数指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>什么是链表：像链条一样存储结构，与结构体不同的是结构体中多了个结构体指针，A结构体存了一些结构体成员还存了B结构体指针，</p>
<p>B结构体存了相同的结构体成员和指向C的结构体指针，以此类推</p>
<p>下面举例说明struct * p, *head, * tail(链表有头有尾， head标记头节点， tail标记尾节点)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct *p, *head, *tail;</span><br><span class="line">p = (struct STUDENT)malloc(sizeof(struct STUDENT));</span><br><span class="line">head = p;//由于为空链表，head仅需标记，无需填入内容</span><br><span class="line">tail = p;//尾节点为NULL</span><br><span class="line">head-&gt;next = NULL;//next指向NULL</span><br><span class="line">//接下来填入节点</span><br><span class="line">for(int  i = 0; i&lt;n ;i++)</span><br><span class="line">&#123;</span><br><span class="line">    p = (struct STUDENT)malloc(sizeof(struct STUDENT));</span><br><span class="line">    scanf(&quot;%s&quot;, p-&gt;name);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;p-&gt;id);</span><br><span class="line">    tail-&gt;next = p;</span><br><span class="line">    tail = p;//尾节点指向新的开辟的节点</span><br><span class="line">    tail-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line">p = head-&gt;next;</span><br><span class="line">while(p!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s, %d&quot;, p-&gt;name, -&gt;id);</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;//链表的遍历</span><br></pre></td></tr></table></figure>

<p>一个节点是一个有异常处理能力的作用域</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;&lt;/p&gt;</span><br><span class="line">    // 可能抛出异常的代码&lt;/p&gt;</span><br><span class="line">    throw std::runtime_error(&quot;发生错误&quot;);&lt;/p&gt;</span><br><span class="line">&#125; catch (const std::exception&amp; e) &#123;&lt;/p&gt;</span><br><span class="line">    // 处理异常&lt;/p&gt;</span><br><span class="line">    std::cerr &lt;&lt; &quot;捕获到异常: &quot; &lt;&lt; e.what() &lt;&lt; &#x27;\n&#x27;;&lt;/p&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">catch (const std::exception&amp; e)</span><br><span class="line">//      ↑     ↑         ↑   ↑</span><br><span class="line">//      │     │         │   └─ 引用变量名</span><br><span class="line">//      │     │         └───── 异常类名</span><br><span class="line">//      │     └─────────────── 命名空间</span><br><span class="line">//      └───────────────────── 常量限定符</span><br></pre></td></tr></table></figure>

<p>异常有不同类型</p>
<p>应用</p>
<p>1.异常传播</p>
<p>如果一个函数中的try-catch没有捕获到异常，异常会向上抛给调用者，直到被合适的catch块捕获或导致程序终止。</p>
<p>（try抛出的异常类型与catch的类型不匹配）</p>
<p>2.多catch块</p>
<p>可以有多个catch块来捕获不同类型的异常，按照从上至下的顺序匹配。</p>
<p>忽略异常传播（上层调用异常处理无法判断）</p>
<p>不恰当catch块</p>
<h1 id="2-des加密"><a href="#2-des加密" class="headerlink" title="2.des加密"></a>2.des加密</h1><p>des是经过festial网络的块加密，并且对于标准的中字节处理是大端序处理，而des加密是对称加密，des处理字节的方式是大端序，接受64位明文和64位密文返回64位明文</p>
<p>那如果不够64位，根据一定的填充法填充64位</p>
<h2 id="什么是festial网络？"><a href="#什么是festial网络？" class="headerlink" title="什么是festial网络？"></a>什么是festial网络？</h2><p>1.将明文分为左右两个部分</p>
<p>2.将右半部分作为输入，通过f函数与子密钥进行运算</p>
<p>3.将左面的明文与f函数的输出异或，生成新的有半部分</p>
<p>4.左右部分进行交换，进入下一轮</p>
<p> <strong>PKCS#7</strong> 方案</p>
<h2 id="PKCS填充方法"><a href="#PKCS填充方法" class="headerlink" title="PKCS填充方法"></a>PKCS填充方法</h2><ul>
<li>计算需要填充的字节数 <code>pad_len = block_size - (len(data) % block_size)</code></li>
<li>每个填充字节的值都等于 <code>pad_len</code></li>
<li>如果数据长度恰好是块大小的整数倍，则额外填充一个完整的块（这是因为des解密会检索最后一个数据：解密算法可以<strong>总是</strong>去除最后一个字节的值作为填充长度，然后移除相应数量的字节）</li>
</ul>
<p>比如“abcde”填充9-len（”abcde“）%9 &#x3D; 4</p>
<p>即填充\x04</p>
<h2 id="密钥生成机制"><a href="#密钥生成机制" class="headerlink" title="密钥生成机制"></a>密钥生成机制</h2><h2 id="文献参考"><a href="#文献参考" class="headerlink" title="文献参考"></a>文献参考</h2><p><a target="_blank" rel="noopener" href="https://sgsgsama.github.io/ctf/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/DES/#reference">DES - SGSG’s Blog</a></p>
<p>密钥是64位，但是实际上真正的密钥是56位，因为原密钥有8位是校验位（每字节最后一位为校验位，保证1出现的次数为奇数）</p>
<p>之后这个密钥再拆分成左右两个28位的密钥</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title function_">PC1</span><span class="params">(<span class="type">uint64_t</span> key)</span>    <span class="comment">//pair&lt;uint32_t, uint32_t&gt;在utility头文件，返回相当于c结构体有两个结构变量uint_t的数据类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> pc1L[] = &#123;<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">                      <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">                      <span class="number">10</span>, <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">                      <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>&#125;;</span><br><span class="line">   <span class="type">uint8_t</span> pc1R[] = &#123;<span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">                      <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">                      <span class="number">14</span>, <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">                      <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; keypair&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">28</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        keypir.first |= (key[i]&gt;&gt;(<span class="number">64</span> - pc1L[i]))&lt;&lt;(<span class="number">27</span>-i);</span><br><span class="line">        keypair.second |= (key[i]&gt;&gt;(<span class="number">64</span> - pc1R[i]))&lt;&lt;(<span class="number">27</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个生成的28位子密钥先要左旋特定位数（循环左移）（右旋就是循环右移）</p>
<p>pc2中有一个盒决定选择哪48位作为密钥</p>
<p>新的子密钥由上一个生成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">keyGen</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; keypair)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> offest[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        keypair.first = leftRotate(keypair.first, offsetr[i]);</span><br><span class="line">        keypair.second = leftRotate(keypair.second, offset[i]);</span><br><span class="line">        keys[i] = PC2(((<span class="type">uint64_t</span>)keypair.first&lt;&lt;<span class="number">8</span>)|keypair.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">PC2</span><span class="params">(<span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> pc2[]=&#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line">                     <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">                     <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">8</span>,</span><br><span class="line">                     <span class="number">16</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">2</span>,</span><br><span class="line">                     <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">                     <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">                     <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">                     <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">uint64_t</span> subKey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">48</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         subKey |= ((key&gt;&gt;(<span class="number">56</span>-pc[i]))&amp;<span class="number">1</span>)&lt;&lt;(<span class="number">47</span>-i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subkey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此生成了16个48位密钥</p>
<p>至此密钥已成，将明文分为左右32位进入feistel网络</p>
<h2 id="接下来为加密代码"><a href="#接下来为加密代码" class="headerlink" title="接下来为加密代码"></a>接下来为加密代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">desEncrypt</span><span class="params">(<span class="type">uint64_t</span> * plain, <span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    keyGen(PC1(key));</span><br><span class="line">    <span class="type">uint64_t</span> afterIp = IP(* plain);</span><br><span class="line">    <span class="type">uint32_t</span> l = afterIP&gt;&gt;<span class="number">32</span>, r = afterIp&amp;<span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; lr = goRound(l, r, Keys[i]);</span><br><span class="line">        l = lr.first;</span><br><span class="line">        r = lr.second;</span><br><span class="line">    &#125;</span><br><span class="line">    *plain = ((<span class="type">uint64_t</span>)r&lt;&lt;<span class="number">32</span>)|l;</span><br><span class="line">    *plain = FP(*plain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始时对明文进行ip置换之后加密后对密文进行fp置换得到最后的密文，当然这仅仅只是简单的映射（一 一对应关系，一个集合的元素对应另一个集合的元素）</p>
<h2 id="接下来就是ip与fp置换"><a href="#接下来就是ip与fp置换" class="headerlink" title="接下来就是ip与fp置换"></a>接下来就是ip与fp置换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">IP</span> <span class="params">(<span class="type">uint64_t</span> message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> afterIP = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> ip[] = &#123;<span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">                    <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                    <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">                    <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">                    <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">                    <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">                    <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        afterIp |= ((message&gt;&gt;(<span class="number">64</span>-ip[i])&amp;<span class="number">1</span>)&lt;&lt;(<span class="number">63</span>-i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterIP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">FP</span><span class="params">(<span class="type">uint64_t</span> message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> afterFP = <span class="number">0</span>;</span><br><span class="line">     <span class="type">uint8_t</span>     fp[]    = &#123;<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">                    <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">                    <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">                    <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">                    <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">                    <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">                    <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">                    <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>, <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">64</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        afterFP |= ((message&gt;&gt;(<span class="number">64</span>-fp[i]))&amp;<span class="number">1</span>)&lt;&lt;(<span class="number">63</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="feistel轮函数如下所示"><a href="#feistel轮函数如下所示" class="headerlink" title="feistel轮函数如下所示"></a>feistel轮函数如下所示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">feistel</span><span class="params">(<span class="type">uint32_t</span> a, <span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> t = expand(a)^key;</span><br><span class="line">    <span class="type">uint32_t</span> afterS = S(t);</span><br><span class="line">    afterS = P(afterS);</span><br><span class="line">    <span class="keyword">return</span> afterS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title function_">goRound</span><span class="params">(<span class="type">uint32_t</span> l, <span class="type">uint32_t</span> r, <span class="type">uint64_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(&#123;r, l^feistel(r, key)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="拓展与映射"><a href="#拓展与映射" class="headerlink" title="拓展与映射"></a>拓展与映射</h2><p>先通过e盒拓展到48位与密钥异或，之后通过映射成32位，再由P盒最后一次置换输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">expand</span><span class="params">(<span class="type">uint32_t</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> e[] = &#123;<span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">                   <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">                   <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">                   <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">                   <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">                   <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">                   <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">                   <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">uint64_t</span> afterE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, i&lt;<span class="number">48</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        afterE |= ((a&gt;&gt;(<span class="number">32</span>-e[i]))&amp;<span class="number">1</span>)&lt;&lt;(<span class="number">47</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要有48位变为32位，这是映射关系</p>
<p>48是8*6而32是8乘以4</p>
<p>48位会每6位进入一个s盒（4行*16列），例如：(总共8个s盒)</p>
<ul>
<li><p>第 <strong>1-6位</strong>（总共48位中的前6位） → 输入给 <strong>S盒1</strong></p>
</li>
<li><p>第 <strong>7-12位</strong> → 输入给 <strong>S盒2</strong></p>
<p>每块的第一个和第六个位用于索引行，其他4个位用于索引列，最会得到一个32位输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">S</span><span class="params">(<span class="type">int64_t</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span> row = (((a&gt;&gt;(i*<span class="number">6</span>))&amp;<span class="number">0x20</span>)&gt;&gt;<span class="number">4</span>)|((a&gt;&gt;(i*<span class="number">6</span>))&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="type">uint8_t</span> col = ((a&gt;&gt;(i*<span class="number">6</span>))&amp;<span class="number">0x1E</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        res |= S_box[i][row*<span class="number">16</span>+col]&lt;&lt;(<span class="number">4</span>*i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>P置换就是再次打乱S盒的输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">P</span><span class="params">(<span class="type">uint64_t</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> p[] = &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">                   <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">                   <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">                   <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">                   <span class="number">2</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">                   <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>,</span><br><span class="line">                   <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>,</span><br><span class="line">                   <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">25</span>&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> afterP = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        afterP |= ((a&gt;&gt;(<span class="number">32</span>-p[i]))&amp;<span class="number">1</span>)&lt;&lt;(<span class="number">31</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> afterP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/learning/des.png" alt="des"></p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>1.des加密先由pc1函数由64位去校验位并分为左右两个28位的密钥部分</p>
<p>2.之后进入keygnerate函数进行16循环，每个循环中先左旋特定位数，之后合成56位进行密钥生成</p>
<p>3.接下来明文先进行ip置换，，之后将64位明文分为两个32明文，此后在这进行16次轮加密，每轮后对右面的32位密钥先进行e盒拓展再映射到s盒子在进行p盒置换</p>
<p>4.即将结果first与seond部分交换后返回，共16轮</p>
<p>5.最后将secnd部分提到高32位之后进行fp置换得到密文</p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>由于des加密十分庞大，所以可以通过观察不变的盒子来判断</p>
<h5 id="S盒"><a href="#S盒" class="headerlink" title="S盒"></a>S盒</h5><p>S盒引入了非线性操作，且S盒的每一位都是设计抵抗差分和线性密码分析，一般不会修改S盒</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">uint8_t S_box[8][64] = </span><br><span class="line">&#123;&#123;14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,</span><br><span class="line"> 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,</span><br><span class="line"> 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,</span><br><span class="line"> 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13&#125;,</span><br><span class="line">&#123;15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,</span><br><span class="line"> 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,</span><br><span class="line"> 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,</span><br><span class="line"> 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9&#125;,</span><br><span class="line">&#123;10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,</span><br><span class="line"> 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,</span><br><span class="line"> 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,</span><br><span class="line"> 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12&#125;,</span><br><span class="line">&#123;7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,</span><br><span class="line"> 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,</span><br><span class="line"> 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,</span><br><span class="line"> 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14&#125;,</span><br><span class="line">&#123;2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,</span><br><span class="line"> 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,</span><br><span class="line"> 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,</span><br><span class="line"> 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3&#125;,</span><br><span class="line">&#123;12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,</span><br><span class="line"> 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,</span><br><span class="line"> 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,</span><br><span class="line"> 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13&#125;,</span><br><span class="line">&#123;4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,</span><br><span class="line"> 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,</span><br><span class="line"> 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,</span><br><span class="line"> 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12&#125;,</span><br><span class="line">&#123;13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,</span><br><span class="line"> 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,</span><br><span class="line"> 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,</span><br><span class="line"> 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="p盒"><a href="#p盒" class="headerlink" title="p盒"></a>p盒</h3><p>p盒子的特殊设计使得每轮由同一s盒子输出的4个bit位在下一轮都能分散到4个不同的s盒进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint8_t p[] = </span><br><span class="line">&#123;16, 7, 20, 21,</span><br><span class="line"> 29, 12, 28, 17,</span><br><span class="line"> 1, 15, 23, 26,</span><br><span class="line"> 5, 18, 31, 10,</span><br><span class="line"> 2, 8, 24, 14,</span><br><span class="line"> 32, 27, 3, 9,</span><br><span class="line"> 19, 13, 30, 6,</span><br><span class="line"> 22, 11, 4, 25&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>e盒是将32位拓展为48位，增强混淆能力</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint8_t e[] = </span><br><span class="line">&#123;32, 1, 2, 3, 4, 5,</span><br><span class="line">4, 5, 6, 7, 8, 9,</span><br><span class="line">8, 9, 10, 11, 12, 13,</span><br><span class="line">12, 13, 14, 15, 16, 17,</span><br><span class="line">16, 17, 18, 19, 20, 21,</span><br><span class="line">20, 21, 22, 23, 24, 25,</span><br><span class="line">24, 25, 26, 27, 28, 29,</span><br><span class="line">28, 29, 30, 31, 32, 1&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是des加密已经不安全，且加密严重依赖系统程序，且des加密为大端序，现代大多数计算机多为小端序，所以难以实现</p>
<p>由于为对称加密，只要知道16个子密钥就可以根据feistel网络特性将密文当输入，密钥倒着用反推回去就</p>
<h1 id="3-base58"><a href="#3-base58" class="headerlink" title="3.base58"></a>3.base58</h1><p>base58是在base64上去除了比较混淆的字符（0和O，小写字母l与大写字母I，+与*）</p>
<p>剩下的按0<del>9A</del>Za~z排列</p>
<p>无法用整字节转换，所以要将一串转为base58</p>
<p>常见到len*138&#x2F;100</p>
<p>这其实是len*log(256) &#x3D; log(100)乘以base58所需的最大长度</p>
<h2 id="base58加密的关键一步是大数除法"><a href="#base58加密的关键一步是大数除法" class="headerlink" title="base58加密的关键一步是大数除法"></a>base58加密的关键一步是大数除法</h2><p>怎么解大数除法，这就要模拟，什么是模拟，模拟就是在纸上算然后将思路以计算机语言实现</p>
<p>输入是大多是字符串，例如256进制的有0x01, 0xfa, 0xff那么让他们除以两个在一起除58，得到的余数传给下一个</p>
<p>就类似数学中的除法，取余，这里可以想一下计算机中的十进制和数学上的除法就可以理解了</p>
<h2 id="接下来看base58加密与解密"><a href="#接下来看base58加密与解密" class="headerlink" title="接下来看base58加密与解密"></a>接下来看base58加密与解密</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">// Base58字符表（去除了容易混淆的字符）</span><br><span class="line">static const char BASE58_ALPHABET[] = </span><br><span class="line">    &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;;</span><br><span class="line"></span><br><span class="line">// ==================== Base58 编码 ====================</span><br><span class="line"></span><br><span class="line">// Base58编码函数</span><br><span class="line">char* base58_encode(const uint8_t* data, size_t data_len) &#123;</span><br><span class="line">    if (data == NULL || data_len == 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 统计前导0的数量（前导0编码为&#x27;1&#x27;）</span><br><span class="line">    size_t zeros = 0;</span><br><span class="line">    while (zeros &lt; data_len &amp;&amp; data[zeros] == 0) &#123;</span><br><span class="line">        zeros++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 计算最大输出长度：log58(256) ≈ 1.3656</span><br><span class="line">    size_t max_output_len = (data_len - zeros) * 138 / 100 + 2;</span><br><span class="line">    uint8_t* buffer = (uint8_t*)calloc(max_output_len, sizeof(uint8_t));</span><br><span class="line">    if (buffer == NULL) return NULL;</span><br><span class="line">    </span><br><span class="line">    // 核心编码算法：将256进制转换为58进制</span><br><span class="line">    size_t buffer_len = 0;</span><br><span class="line">    for (size_t i = zeros; i &lt; data_len; i++) &#123;</span><br><span class="line">        int carry = data[i];</span><br><span class="line">        </span><br><span class="line">        // 将carry加到已有的58进制数中</span><br><span class="line">        for (size_t j = 0; j &lt; buffer_len || carry &gt; 0; j++) &#123;</span><br><span class="line">            if (j == buffer_len) &#123;</span><br><span class="line">                buffer_len++;</span><br><span class="line">            &#125;</span><br><span class="line">            carry += 256 * buffer[j];</span><br><span class="line">            buffer[j] = carry % 58;                 //核心加密就是x*58^58(j-1)+……+x*58^0所以下面转buffer最后一位仅需模最低为乘256模58就可，而余数留着接下来计算</span><br><span class="line">            carry /= 58;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 构建输出字符串</span><br><span class="line">    size_t output_len = zeros + buffer_len;</span><br><span class="line">    char* output = (char*)malloc(output_len + 1);</span><br><span class="line">    if (output == NULL) &#123;</span><br><span class="line">        free(buffer);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 添加前导&#x27;1&#x27;</span><br><span class="line">    for (size_t i = 0; i &lt; zeros; i++) &#123;</span><br><span class="line">        output[i] = BASE58_ALPHABET[0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 添加58进制数字（注意buffer是反序的）</span><br><span class="line">    for (size_t i = zeros; i &lt; output_len; i++) &#123;</span><br><span class="line">        output[i] = BASE58_ALPHABET[buffer[buffer_len - (i - zeros) - 1]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    output[output_len] = &#x27;\0&#x27;;</span><br><span class="line">    free(buffer);</span><br><span class="line">    return output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ==================== Base58 解码 ====================</span><br><span class="line"></span><br><span class="line">// 查找Base58字符对应的值</span><br><span class="line">static int base58_char_value(char c) &#123;</span><br><span class="line">    if (c &gt;= &#x27;1&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) return c - &#x27;1&#x27;;</span><br><span class="line">    if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;H&#x27;) return c - &#x27;A&#x27; + 9;</span><br><span class="line">    if (c &gt;= &#x27;J&#x27; &amp;&amp; c &lt;= &#x27;N&#x27;) return c - &#x27;J&#x27; + 17;</span><br><span class="line">    if (c &gt;= &#x27;P&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) return c - &#x27;P&#x27; + 22;</span><br><span class="line">    if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;k&#x27;) return c - &#x27;a&#x27; + 33;</span><br><span class="line">    if (c &gt;= &#x27;m&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;m&#x27; + 44;</span><br><span class="line">    return -1;  // 非法字符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Base58解码函数</span><br><span class="line">uint8_t* base58_decode(const char* encoded, size_t* output_len) &#123;</span><br><span class="line">    if (encoded == NULL) &#123;</span><br><span class="line">        if (output_len) *output_len = 0;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    size_t encoded_len = strlen(encoded);</span><br><span class="line">    if (encoded_len == 0) &#123;</span><br><span class="line">        if (output_len) *output_len = 0;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 统计前导&#x27;1&#x27;的数量（&#x27;1&#x27;对应值0）</span><br><span class="line">    size_t ones = 0;</span><br><span class="line">    while (ones &lt; encoded_len &amp;&amp; encoded[ones] == &#x27;1&#x27;) &#123;</span><br><span class="line">        ones++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 将Base58字符串转换为数值</span><br><span class="line">    uint8_t* values = (uint8_t*)malloc(encoded_len - ones);</span><br><span class="line">    if (values == NULL) return NULL;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = ones; i &lt; encoded_len; i++) &#123;</span><br><span class="line">        int value = base58_char_value(encoded[i]);     //base58加密后的结果转对应的下标</span><br><span class="line">        if (value &lt; 0) &#123;</span><br><span class="line">            free(values);</span><br><span class="line">            if (output_len) *output_len = 0;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        values[i - ones] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 计算最大输出长度：log256(58) ≈ 0.733</span><br><span class="line">    size_t max_output_len = (encoded_len - ones) * 733 / 1000 + 2;</span><br><span class="line">    uint8_t* buffer = (uint8_t*)calloc(max_output_len, sizeof(uint8_t));</span><br><span class="line">    if (buffer == NULL) &#123;</span><br><span class="line">        free(values);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 核心解码算法：将58进制转换为256进制</span><br><span class="line">    size_t buffer_len = 0;</span><br><span class="line">    for (size_t i = 0; i &lt; encoded_len - ones; i++) &#123;</span><br><span class="line">        int carry = values[i];</span><br><span class="line">        </span><br><span class="line">        for (size_t j = 0; j &lt; buffer_len || carry &gt; 0; j++) &#123;</span><br><span class="line">            if (j == buffer_len) &#123;</span><br><span class="line">                buffer_len++;</span><br><span class="line">            &#125;</span><br><span class="line">            carry += 58 * buffer[j];           //58进制转10进制数，然后激素那，没反序，引入新的位原来都要乘58</span><br><span class="line">            buffer[j] = carry % 256;</span><br><span class="line">            carry /= 256;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 构建输出数据</span><br><span class="line">    size_t result_len = ones + buffer_len;</span><br><span class="line">    uint8_t* result = (uint8_t*)malloc(result_len);</span><br><span class="line">    if (result == NULL) &#123;</span><br><span class="line">        free(values);</span><br><span class="line">        free(buffer);</span><br><span class="line">        if (output_len) *output_len = 0;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 添加前导0</span><br><span class="line">    memset(result, 0, ones);</span><br><span class="line">    </span><br><span class="line">    // 复制数据（注意buffer是反序的）</span><br><span class="line">    for (size_t i = 0; i &lt; buffer_len; i++) &#123;</span><br><span class="line">        result[ones + i] = buffer[buffer_len - i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (output_len) *output_len = result_len;</span><br><span class="line">    </span><br><span class="line">    free(values);</span><br><span class="line">    free(buffer);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-python逆向"><a href="#4-python逆向" class="headerlink" title="4.python逆向"></a>4.python逆向</h1><h2 id="1-常见的情况（pyc文件介于源码与字节码之间，pyd文件是动态链接库）"><a href="#1-常见的情况（pyc文件介于源码与字节码之间，pyd文件是动态链接库）" class="headerlink" title="1.常见的情况（pyc文件介于源码与字节码之间，pyd文件是动态链接库）"></a>1.常见的情况（pyc文件介于源码与字节码之间，pyd文件是动态链接库）</h2><p>一.pyc文件这届uncompyle6反编译（进到python3.8版本）</p>
<p><a target="_blank" rel="noopener" href="https://www.lddgo.net/string/pyc-compile-decompile">在线Python pyc文件编译与反编译</a></p>
<p>二.给了个txt文件里面是pyc字节码</p>
<p>1.读取py字节码2.根据opcode文件查询意思</p>
<p>  三.exe打包的py文件</p>
<p>1.通过脚本变为结构体和文件2.再把时间属性和魔法数字放回去保存3.uncompyle6</p>
<p>四.pyc加花</p>
<p>1..uncompyle6和字节码判断是否加花2.读取co_code的长度3.去掉花并修改co_code长度4.uncompyle6</p>
<h2 id="2-pyc文件直接uncompyle6反编译"><a href="#2-pyc文件直接uncompyle6反编译" class="headerlink" title="2.pyc文件直接uncompyle6反编译"></a>2.pyc文件直接uncompyle6反编译</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m xx.py   # m为module，直接将python模块作为脚本运行，生成pyc文件</span><br></pre></td></tr></table></figure>

<p>而在命令符中python .\xxx.pyc可以直接运行</p>
<h2 id="3-二-给了个txt文件里面是pyc字节码"><a href="#3-二-给了个txt文件里面是pyc字节码" class="headerlink" title="3.二.给了个txt文件里面是pyc字节码"></a>3.二.给了个txt文件里面是pyc字节码</h2><p>python3的开头前4个字节为魔法数字，之后4个字节为位字段（bit field），</p>
<p>接着4字节为时间戳，再4字节为源文件文件大小，然后为序列化的代码对象</p>
<p>接下来是对位字段的解释，位字段是为了能够复现编译的结果</p>
<p>根据python的官方文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果位字段为 0，则该 pyc 是传统的基于时间戳的 pyc</span><br><span class="line">如果位字段的最低位被设置，则该 pyc 是基于哈希的 pyc。</span><br></pre></td></tr></table></figure>

<p>有操作数指令：3 字节**（1字节操作码 + 2字节操作数）</p>
<h4 id="Python-3-0-3-5"><a href="#Python-3-0-3-5" class="headerlink" title="Python 3.0-3.5"></a><strong>Python 3.0-3.5</strong></h4><ul>
<li>依然使用 <strong>3 字节</strong>指令格式</li>
</ul>
<h4 id="Python-3-6"><a href="#Python-3-6" class="headerlink" title="Python 3.6+"></a><strong>Python 3.6+</strong></h4><ul>
<li>改为 <strong>2 字节</strong>指令格式：<ul>
<li>第1字节：操作码</li>
<li>第2字节：参数（如果指令需要参数）</li>
</ul>
</li>
</ul>
<p>010editor打开pyc文件python2的前8位是python2的魔法数字，python3是前16位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import dis, marshal         //marshal库用来装载，dis用于反编译</span><br><span class="line">f = open(&quot;1.cpython-313.pyc&quot;, &quot;rb&quot;).read()</span><br><span class="line">code = marshal.loads(f[16:])   //将序列化的代码转换为可执行的二进制文件</span><br><span class="line">dis.dis(code)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0           RESUME                   0        </span><br><span class="line"></span><br><span class="line">1           LOAD_CONST               0 (&lt;code object check at 0x000001F74B8489D0, file &quot;D:\homework\learn\1.py&quot;, line 1&gt;) //放在栈顶</span><br><span class="line">            MAKE_FUNCTION</span><br><span class="line">            STORE_NAME               0 (check)</span><br><span class="line"></span><br><span class="line">6           LOAD_NAME                1 (print)//从co_name[0]中加载print内置函数并放栈顶</span><br><span class="line">            PUSH_NULL          //null用于错误处理和性能优化</span><br><span class="line">            LOAD_NAME                0 (check)</span><br><span class="line">            PUSH_NULL</span><br><span class="line">            CALL                     0  //先取0个参数，之后nullpop，之后执行check返回result</span><br><span class="line">            CALL                     1</span><br><span class="line">            POP_TOP</span><br><span class="line">            RETURN_CONST             1 (None)</span><br></pre></td></tr></table></figure>

<p> LOAD_CONST将值推放到栈顶，</p>
<p>load_fast把这个加载局部变量</p>
<p>load_global是将全局变量或内置函数推到栈顶</p>
<p>LOAD_NAME  将关联值推送到堆栈</p>
<p>STORE_FAST存储局部变量（将tos（栈）储存将存到本地）</p>
<p>GET_iter(获取迭代器)FOR_ITER（执行迭代器）</p>
<p>LOAD_FAST&#96;临时从局部变量中加载到栈中</p>
<p>SETUP_LOOP              28 (to 30)&#x2F;&#x2F;循环开始，28是相对偏移30是绝对指令位置（当前指令位置+相对偏移）</p>
<p>BINARY_SUBTRACT tos &#x3D; tos1 - tos（tos为栈顶tos1为栈的下一位）</p>
<p>BINARY_MOUDULO    tos &#x3D; tos1 % tos</p>
<p>BINARARY_RSHIFT   num(tos &#x3D; tos1&gt;&gt;tos)   &#x2F;&#x2F;之后原来的tos1和tos替换为新的tos</p>
<h2 id="4-将一堆pyc文件打包成exe"><a href="#4-将一堆pyc文件打包成exe" class="headerlink" title="4.将一堆pyc文件打包成exe"></a>4.将一堆pyc文件打包成exe</h2><p><img src="/buuctf/3.jpg" alt="3"></p>
<p>看图标知道是pyc打包的程序，并非标准exe文件，是有着exe头戴着python解释器的，以pyc文件为基础的exe文件，也当然就不用ida</p>
<p>先修头，头文件的二进制在0xE3之前（#define TYPE_CODE 0xE3，0xE3是marshal模块对代码对象的类型标记）</p>
<p>直接解包python pyinstxtractor.py   “绝对路径”，这里由于头被修改</p>
<p>python文件打包成exe文件会将pyc文件的部分信息抹去而这些信息都在struct文件中</p>
<h2 id="5-加花的pyc"><a href="#5-加花的pyc" class="headerlink" title="5.加花的pyc"></a>5.加花的pyc</h2><p>1..uncompyle6和字节码判断是否加花（加花会报错）</p>
<p>2.读取co_code的长度（指令的长度由字节码指令序列决定，指令增减后都要改大小）</p>
<p>len(code.co_code)一个操作3字节</p>
<p>3.去掉花并修改co_code长度</p>
<p>先uncompyle6反编译看花是什么，然后找到操作码对应的的16进制数，然后删去（）</p>
<p>之后根据操作在内存的操作数值为多少在010editor找到对应的，修改对应的值（len-删去的字节）</p>
<p>opcode可在python文件夹的include文件夹opcodexxx.h文件下</p>
<p>4.uncompyle6</p>
<h1 id="5-mfc逆向"><a href="#5-mfc逆向" class="headerlink" title="5.mfc逆向"></a>5.mfc逆向</h1><p>mfc程序是根据c++的mfc库编写的程序，主要是使用xspy去解决问题</p>
<p>mfc要找程序基址与函数的偏移</p>
<p><img src="/reverselearn/1.jpg" alt="1"></p>
<p>主要是找message map&#x3D;0x0000000140004E80(201500_ezre_dump_SCY.exe+ 0x004e80 )（消息映射表区域）</p>
<p>关注确定按钮即oncommand响应按钮（处理菜单、控件和快捷键）</p>
<p>接着找到偏移</p>
<p>然后使用detect it easy软件找到基址</p>
<p>由于mfc是消息映射，可通过导入结构体办法还原</p>
<p>接着开始导入结构体，在view菜单栏下的open subview-&gt;local type（本地类型）</p>
<p>用于存储数据库的基本类型（如struct，enum（枚举），union（联合体），typedef别名，指针类型）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://changye123456.github.io">无夜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://changye123456.github.io/2026/01/24/%E9%80%86%E5%90%91%E6%89%8B%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/">https://changye123456.github.io/2026/01/24/%E9%80%86%E5%90%91%E6%89%8B%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://changye123456.github.io" target="_blank">wuye的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/reverse/">reverse</a></div><div class="post-share"><div class="social-share" data-image="/images/b0c1d74766dd8bce0ad860be15c46993a.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/27/buu/" title="buu"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">buu</div></div><div class="info-2"><div class="info-item-1">魔法师的逆向之旅1.revese2一道简单的字符替换 2.内涵的软件DBAPP{49d3c93df25caad81232130f3d2ebfad} 我还以为有什么加密，结果找半天没找着，直接将DBAPP改为flag就过了 3.新年快乐打开一看内容很少，查壳，为upx壳 4.xor12345678910111213#include&lt;stdio.h&gt;int main(void)&#123;​     char arry[] = &#123;0x66,0xA,0x6B,0xC,0x77,0x26,0x4F,0x2E,0x40,0x11,0x78,0xD,0x5A,0x3B,0x55,0x11,0x70,0x19,0x46,0x1F,0x76,0x22,0x4D,0x23,0x44,0xE,0x67,0x6,0x68,0xF,0x47,0x32,0x4F,0x0&#125;;​    //char arry[] = &quot;f\nk\x0cw&amp;O.@\x11x\rZ;U\x11p\x19F\x1fv\&quot;M#D\x0eg\x06h\x0fG2O\x00&q...</div></div></div></a><a class="pagination-related" href="/2026/01/22/misc%E6%B3%95%E6%9C%AF/" title="misc法术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">misc法术</div></div><div class="info-2"><div class="info-item-1">misc起始受大佬的启发我也写个misc总结，边写边学知识 当然这并非一日之功，所以这篇会持续更新，当然本人主项是逆向魔法师，但也兼职msic，也会持续学逆向和msic，以后可能也会写点开发 1 url编码先说一下url是统一资源定位符，是互联网上用于标识和定位资源的唯一字符串 这里写一下url的几个说明（你进入了url的世界，你必须遵守以下规则，否则你将无法正确得到url） 1.url仅支持ascii码传送 2.url encoding编码字符导能传输的格式（非ascii码想办法转为ascii码形式） 3.urlencoding使用%加上两个十六进制数编码不支持的字符 4.url不能有空格，urlencoding    保留字符（可以直接传送） percent-encoding    newline %0A or %0D or %0D%0A   space %20   ! %21   # %23   $ %24   % %25   &amp; %26   ‘ %27   ( %28   ) %29   * %2A   + %2B   , %2C   &#x2F; %2F   :...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/12/21/wp/" title="wp"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-21</div><div class="info-item-2">wp</div></div><div class="info-2"><div class="info-item-1">MOECTF如何上传图片将图片文件夹放在source文件夹下面，一定不要与文件名字一样， 之后mark语法即可(赞美徐✌) 1.upx_revange 显然上面版本号下面0D将upx！扣掉 加上55 50 58 21（upx！）通过编辑中的插入字节 之后 upx -d脱壳0 lY7bW&#x3D;\ck?eyjX7]TZ\}CVbh\tOyTH6&gt;jH7XmFifG]H7明显为密文 sub_7FF6F2A61000直接就是base64标准表  Block &#x3D; ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_;  这个block是指针，指向的偏移地址就是base64表   t &#x3D; *ptr ^ 0xE;证明base64异或0xe之后进行base64加密 OLMJKHIFGDEBC@A^_]Z[XYVWTolmjkhifgdebc&#96;a~|}z{xyvwt&gt;?&lt;&#x3D;:;8967%!这是标准base64表异或然后加密的结果 这里插一句一开始让ai干的结果生...</div></div></div></a><a class="pagination-related" href="/2026/02/02/VNctf/" title="VNctf"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-02</div><div class="info-item-2">VNctf</div></div><div class="info-2"><div class="info-item-1">ez_maze这回v&amp;N也是爆零了，等我有实力第一个投的绝对就是v&amp;n，所以也是来wp大学习这是mfc逆向，mfc是微软提供的一种c++的类库，当然这道题还有upx壳   红了一片，upx0,upx1,upx2，upx!，upx的各种标志全没有了 一边来说运行两次然后找push就行了但这道题upx代码与源代码在  但是这道题并非常见的在两次运行，跳过前面的系统代码，并没见到pushad（通用寄存器），pushfd（标志寄存器），push，还有lea但是三次运行找到了jmp 112419_ezre.7FF6518D102A这一看就是主程序入口， 进去一看这题将显示的push  rax等给整没了 1LEA 目标寄存器, [内存寻址表达式]   //通过内存地址（相对地址，偏移量）计算出有效地址  不过还后留下了lea与push rdx，下访问断点，运行程序，直接到一堆pop这太对了  首先得用cff-exploer改配置  在头文件的characteristics选上executable 再在可选头文件的dllcharacteristics去除dll可移动  之后一直...</div></div></div></a><a class="pagination-related" href="/2026/02/20/qctfweek3/" title="qctfweek3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-20</div><div class="info-item-2">qctfweek3</div></div><div class="info-2"><div class="info-item-1">1.Fisher题目有提示是我要一个好点的钩子，这是要hook得好的鱼饵吗  这是main函数的主逻辑 tAZ5tAZ5tAZ5vg7F2RZF2RZQ0gv5yCfAxSZKzq&#x3D;&#x3D;一眼就是密文，很可能是base64加密， 进sub_7FF62A7214B0加密函数去追 然后有映射表，解出NO_NO_NO_This_is_the_bad_one，果然是fake flag，sparkctf也有几个看到汇编直接没绷住，100%跳转错误 The fisherman doesn’t like your bait.\n， 我有一计即使要看base64加密后是不是还干了些什么，就要给str打硬件断点   快进到加密结束  直接就是下硬件断点  果然寻到另一处加密，核心是tea加密，这是老熟人了 写一下解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717...</div></div></div></a><a class="pagination-related" href="/2026/02/02/androidleearn/" title="androidleearn"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-02</div><div class="info-item-2">androidleearn</div></div><div class="info-2"><div class="info-item-1">一段dex文件的smali代码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576     修饰符  /* 私有   静态   不可修改*/  方法名              参数.method private static final onCreate$lambda-2(Lkotlin/jvm/internal/Ref$IntRef;Lcom/zj/wuaipojie/ui/ChallengeSecond;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/widget/ImageView;Landroid/view/View;)Z（返回值的类型）    .registers 7   //寄存器的数量                              .line 3...</div></div></div></a><a class="pagination-related" href="/2026/01/01/qctfreverse/" title="reverseweekn"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-01</div><div class="info-item-2">reverseweekn</div></div><div class="info-2"><div class="info-item-1">1**[Week2] CPPReverse**一开始n个小时我直接看着c++原程序，结果抽象的一批（附带PDB文件），这个提醒 pdb存着什么（源代码文件路径与行号信息，局部变量、全局变量和类型，函数名和参数信息，类、结构体的成员信息）其实其实映射表（可以类比Android逆向的so层处理） 当然由于笨蛋的我并未发现这点，导致ida程序十分抽象，难度直线飙升，所以先来个禁pdb的  进来直接被一堆不知道什么的东西吓哭了,直接开始动调  这明显是输入，按n改名，一定要改名，后面再次出现就知道他是干什么的  v13 &#x3D; (unsigned __int8)sub_7FF626234970(v16, “flag{“) || *(_BYTE *)sub_7FF626233C10(v30) !&#x3D; 125; 注意这个 *(_BYTE *)明显是字符125按r变成’}’ 这很明显是输入验证 不妨输入flag{123456}123456最白不要是000000那么反序就看不出来了  接下来是重头戏  这是输入突然被推入栈顶，多半是要进行操作了  下一步flag{}没了，这事就知道...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/b0c1d74766dd8bce0ad860be15c46993a.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">无夜</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%81%87%E6%9C%9F%E9%80%86%E5%90%91%E9%AD%94%E6%B3%95%E5%B8%88%E5%AD%A6%E4%B9%A0%E6%B3%95%E6%9C%AF%E7%9A%84%E7%9B%AE%E6%A0%87-%E5%8E%BB%E6%83%B3%EF%BC%8C%E5%8E%BB%E5%AD%A6%EF%BC%8C%E5%8E%BB%E5%BE%81%E6%9C%8D"><span class="toc-number">1.</span> <span class="toc-text">假期逆向魔法师学习法术的目标(去想，去学，去征服)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-try-catch%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88SEH%EF%BC%89%EF%BC%88%E5%85%A8%E7%A7%B0-Structure-Exception-Handler"><span class="toc-number">2.</span> <span class="toc-text">1.try-catch与结构化异常处理（SEH）（全称[Structure Exception Handler]</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-des%E5%8A%A0%E5%AF%86"><span class="toc-number">3.</span> <span class="toc-text">2.des加密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfestial%E7%BD%91%E7%BB%9C%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">什么是festial网络？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PKCS%E5%A1%AB%E5%85%85%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">PKCS填充方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">密钥生成机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E7%8C%AE%E5%8F%82%E8%80%83"><span class="toc-number">3.4.</span> <span class="toc-text">文献参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%B8%BA%E5%8A%A0%E5%AF%86%E4%BB%A3%E7%A0%81"><span class="toc-number">3.5.</span> <span class="toc-text">接下来为加密代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%B0%B1%E6%98%AFip%E4%B8%8Efp%E7%BD%AE%E6%8D%A2"><span class="toc-number">3.6.</span> <span class="toc-text">接下来就是ip与fp置换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#feistel%E8%BD%AE%E5%87%BD%E6%95%B0%E5%A6%82%E4%B8%8B%E6%89%80%E7%A4%BA"><span class="toc-number">3.7.</span> <span class="toc-text">feistel轮函数如下所示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E4%B8%8E%E6%98%A0%E5%B0%84"><span class="toc-number">3.8.</span> <span class="toc-text">拓展与映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-number">3.9.</span> <span class="toc-text">小结一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">3.10.</span> <span class="toc-text">特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#S%E7%9B%92"><span class="toc-number">3.10.1.</span> <span class="toc-text">S盒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p%E7%9B%92"><span class="toc-number">3.10.2.</span> <span class="toc-text">p盒</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-base58"><span class="toc-number">4.</span> <span class="toc-text">3.base58</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#base58%E5%8A%A0%E5%AF%86%E7%9A%84%E5%85%B3%E9%94%AE%E4%B8%80%E6%AD%A5%E6%98%AF%E5%A4%A7%E6%95%B0%E9%99%A4%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">base58加密的关键一步是大数除法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9C%8Bbase58%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86"><span class="toc-number">4.2.</span> <span class="toc-text">接下来看base58加密与解密</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-python%E9%80%86%E5%90%91"><span class="toc-number">5.</span> <span class="toc-text">4.python逆向</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%88pyc%E6%96%87%E4%BB%B6%E4%BB%8B%E4%BA%8E%E6%BA%90%E7%A0%81%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E4%B9%8B%E9%97%B4%EF%BC%8Cpyd%E6%96%87%E4%BB%B6%E6%98%AF%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">1.常见的情况（pyc文件介于源码与字节码之间，pyd文件是动态链接库）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-pyc%E6%96%87%E4%BB%B6%E7%9B%B4%E6%8E%A5uncompyle6%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="toc-number">5.2.</span> <span class="toc-text">2.pyc文件直接uncompyle6反编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8C-%E7%BB%99%E4%BA%86%E4%B8%AAtxt%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%E6%98%AFpyc%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">5.3.</span> <span class="toc-text">3.二.给了个txt文件里面是pyc字节码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-3-0-3-5"><span class="toc-number">5.3.1.</span> <span class="toc-text">Python 3.0-3.5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python-3-6"><span class="toc-number">5.3.2.</span> <span class="toc-text">Python 3.6+</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B0%86%E4%B8%80%E5%A0%86pyc%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90exe"><span class="toc-number">5.4.</span> <span class="toc-text">4.将一堆pyc文件打包成exe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%8A%A0%E8%8A%B1%E7%9A%84pyc"><span class="toc-number">5.5.</span> <span class="toc-text">5.加花的pyc</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-mfc%E9%80%86%E5%90%91"><span class="toc-number">6.</span> <span class="toc-text">5.mfc逆向</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/20/qctfweek3/" title="qctfweek3">qctfweek3</a><time datetime="2026-02-20T07:54:17.000Z" title="发表于 2026-02-20 15:54:17">2026-02-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/17/%E6%96%B0%E5%B9%B4/" title="新年">新年</a><time datetime="2026-02-17T13:37:17.000Z" title="发表于 2026-02-17 21:37:17">2026-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/02/androidleearn/" title="androidleearn">androidleearn</a><time datetime="2026-02-02T07:48:54.000Z" title="发表于 2026-02-02 15:48:54">2026-02-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/02/VNctf/" title="VNctf">VNctf</a><time datetime="2026-02-02T07:48:37.000Z" title="发表于 2026-02-02 15:48:37">2026-02-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/27/buu/" title="buu">buu</a><time datetime="2026-01-27T02:43:02.000Z" title="发表于 2026-01-27 10:43:02">2026-01-27</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By 无夜</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>